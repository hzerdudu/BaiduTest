{"./":{"url":"./","title":"简介","keywords":"","body":"简介 1、测试面试相关 "},"chapter1/readme.html":{"url":"chapter1/readme.html","title":"第1章 课程介绍","keywords":"","body":"第1章 课程介绍 课程定位 帮助大家梳理知识点 讲述面试过程中的要点（技术和非技术） 面试官关注的侧重点 适合人群 已经是测试工程师 掌握Python基础 课程收获 经验丰富的测试人员可以梳理知识体系 部分知识点你没有接触过可以指明学习路线 非技术面过程中可掌握面试侧重点 "},"chapter1/1.1.html":{"url":"chapter1/1.1.html","title":"1.1 整体介绍","keywords":"","body":"1.1 整体介绍 一面：技术面试 Python编程 UI自动化 接口测试 JVM Linux MySQL 二面：项目面试 做过哪些项目 面试者在项目中的价值点 三面：综合素质面试 "},"chapter2/readme.html":{"url":"chapter2/readme.html","title":"第2章 一线互联网公司的面试流程和技巧","keywords":"","body":"第2章 一线互联网公司的面试流程和技巧 本章主要介绍一线互联网公司的面试流程和技巧 "},"chapter2/2.1.html":{"url":"chapter2/2.1.html","title":"2.1 岗位JD分析","keywords":"","body":"2.1 岗位JD分析 开发语言 自动化 性能测试 操作系统 数据库 网络协议 "},"chapter2/2.2.html":{"url":"chapter2/2.2.html","title":"2.2 高级资深测试工程师岗位技能树","keywords":"","body":"2.2 高级资深测试工程师岗位技能树 开发语言 Python等，要有一门专精 数据库 学好MySQL即可 操作系统 学好常用命令 学好监控命令 网络协议 分层协议等 测试技能 自动化 UI自动化 接口自动化 性能 业务能力 "},"chapter2/2.3.html":{"url":"chapter2/2.3.html","title":"2.3 测试架构工程师的能力要求","keywords":"","body":"2.3 测试架构工程师的能力要求 架构师与工程师在技能上并无区别 架构师与工程师的核心区别 架构的意义是什么？ 不同阶段用最小的代价解决不同问题的能力 主要体现在业务能力 比如：初始阶段不一定要大而全的架构，后期可能要考虑高并发等 站在公司层面，为公司解决实际问题 "},"chapter2/2.4.html":{"url":"chapter2/2.4.html","title":"2.4 测试人员的职业规划","keywords":"","body":"2.4 测试人员的职业规划 初级：技术 中级：技术 高级：技术 可以走技术路线或管理路线 资深-->架构 善于专研技术 善于写代码 经理-->总监 善于协调（内部协调、外部协调） 善于汇报（总结、归纳、PPT） CTO/VP "},"chapter2/2.5.html":{"url":"chapter2/2.5.html","title":"2.5 一面考试考察重点","keywords":"","body":"2.5 一面考试考察重点 分类 技术面试 项目面试 综合素质面试 一面--技术面试的考察重点 广博的技术面 会很多框架，这些框架能解决什么问题 会操作系统 会数据库 等等 专精的技术方向 自动化是怎么做的 技术细节 等等 "},"chapter2/2.6.html":{"url":"chapter2/2.6.html","title":"2.6 二面考试考察重点","keywords":"","body":"2.6 二面考试考察重点 核心是价值 为团队做了什么？ 质量 效率：为测试团队做了什么提高效率的事情 为项目做了什么？ 质量 效率 为公司做了什么？ 提高效率，比如持续集成 "},"chapter2/2.7.html":{"url":"chapter2/2.7.html","title":"2.7 三面考试考察重点","keywords":"","body":"2.7 三面考试考察重点 核心是能力 团队协作能力 团队管理能力 核心竞争力 "},"chapter2/2.8.html":{"url":"chapter2/2.8.html","title":"2.8 面试的重点-精彩的自我介绍","keywords":"","body":"2.8 面试的重点-精彩的自我介绍 目的：深刻的第一印象 要求：优秀的语言表达能力 名字：套上场景，让面试官记住你的名字 做过哪些项目，引导面试官后面的面试内容，不然容易被面试官问倒 亲和力 微笑，不要很尬笑，平时多笑笑 让人愿意和面试者成为同事 比如：遇到不会的问题 不好意思，这个问题我没有遇到过，不过我可以从我的角度来尝试回答，有不对的地方请指教 "},"chapter3/readme.html":{"url":"chapter3/readme.html","title":"第3章 一面-Python高级编程和算法面试考点","keywords":"","body":"第3章 一面-Python高级编程和算法面试考点 本章介绍面试时相关的Python高级编程知识和算法 "},"chapter3/3.1.html":{"url":"chapter3/3.1.html","title":"3.1 Python高级编程面试真题及考点分析","keywords":"","body":"3.1 Python高级编程面试真题及考点分析 面试题1：下面代码的打印结果是什么？ import copy a = ('a', 'b', 'c') c = copy.copy(a) d = copy.deepcopy(a) if c == d: print('c和d值相等') if id(c) == id(d): print('c和d地址相等') 考点1：深浅拷贝 考点2：可变对象和不可变对象 面试题2： 下面代码的打印结果是什么？ class Person: x = 5 y = 6 def __init__(self, x, y): self.x = x self.y = y def add(self): return self.x + self.y person = Person(10, 20) person.z = 7 print(person.x) print(person.y) print(Person.x) print(Person.y) print(Person.add(Person)) print(person.add()) print(person.z) print((Person.z)) 考点1：类变量、实例变量 面试题3：Python中一个函数function接收三个参数a，*args，**kwargs，他们分别是什么类型 考点：可变参数 面试题4：请根据列表list1=[1, 2, 3, 4, 5, 6]，使用一行代码生成一个新的列表list2，list2中每个元素是list1中的元素的平方 考点：推导式 面试题5：请将下面列表进行排序list1=[20,15,88,97,76,13,27,49] 考点：排序算法 中级：冒泡 高级：快排 面试题6：请实现@runtime，效果为当调用student_run时会自动打印当前时间 题目 @runtime def student_run(name): print('student' + name + 'run') student_run('张三') 考点：装饰器 面试题7：请简述func1和func2函数的返回值，以及函数运行机制 题目 def func1(): for i in range(1, 5): return i def func2(): for i in range(1, 5): yield i 考点：return和yield的区别 "},"chapter3/3.2.html":{"url":"chapter3/3.2.html","title":"3.2 Python编程面试题","keywords":"","body":"3.2 Python编程面试题 Python中的多线程和多进程有什么区别？ Python中什么是可变数据类型？什么是不可变数据类型？ Python中如何实现单例设计模式？ Python中，一行代码如何实现两个数交换？ Pyhton中的__new__和__init__两个方法有什么区别？ "},"chapter3/3.3.html":{"url":"chapter3/3.3.html","title":"3.3 对象的深浅拷贝面试题","keywords":"","body":"3.3 对象的深浅拷贝面试题 不可变对象的浅拷贝和深拷贝(a为元组) import copy a = ('a', 'b', 'c') b = a c = copy.copy(a) d = copy.deepcopy(a) print(a) # ('a', 'b', 'c') print(b) # ('a', 'b', 'c') print(c) # ('a', 'b', 'c') print(d) # ('a', 'b', 'c') print(id(a)) # 32534104 print(id(b)) # 32534104 print(id(c)) # 32534104 print(id(d)) # 32534104 if c == d: # c和d值相等 print('c和d值相等') if id(c) == id(d): # c和d地址相等 print('c和d地址相等') 可变对象的浅拷贝和深拷贝(a为列表、集合) import copy a = ['a', 'b', 'c'] b = a c = copy.copy(a) d = copy.deepcopy(a) print(a) # ['a', 'b', 'c'] print(b) # ['a', 'b', 'c'] print(c) # ['a', 'b', 'c'] print(d) # ['a', 'b', 'c'] print(id(a)) # 33804232 print(id(b)) # 33804232 print(id(c)) # 33803016 print(id(d)) # 45093832 if c == d: # c和d值相等 print('c和d值相等') if id(c) == id(d): # 不满足，这里不打印 print('c和d地址相等') 可变对象和不可变对象 可变对象：可以修改的对象，包括列表和字典等 不可变对象：一旦创建就不可以修改，包括元组、字符串、数字等 "},"chapter3/3.4.html":{"url":"chapter3/3.4.html","title":"3.4 类变量实例变量类对象实例对象","keywords":"","body":"3.4 类变量实例变量类对象实例对象 类对象和实例对象 class Person: # 类对象 def __init__(self, x, y): self.x = x self.y = y print('x=' + str(x)) print('y=' + str(y)) def add(self): return self.x + self.y # p和p1为示例对象 p = Person(1, 2) p1 = Person(3, 4) # print(Person.add()) # 报错，缺少参数self # print(Person.add(Person))# 报错，Person没有属性x，现在传入的是类对象，实际要求的是实例对象 print(Person.add(Person(3, 4))) # 7,Person(3,4)创建了实例对象 print(p.add()) # 3 类变量和实例变量 class Person: # 类对象 x = 5 y = 6 def __init__(self, x, y): self.x = x self.y = y print('x=' + str(x)) print('y=' + str(y)) def add(self): return self.x + self.y # p和p1为示例对象 p = Person(1, 2) p.z = 7 # 下面三个均为实例变量 print(p.z) # 7 print(p.x) # 1 print(p.y) # 2 print(Person.x) # 5,类变量 "},"chapter3/3.5.html":{"url":"chapter3/3.5.html","title":"3.5 可变参数类型","keywords":"","body":"3.5 可变参数类型 题目 def function(a, *args, **kwargs): print(type(a)) # print(type(args)) # print(type(kwargs)) # print(a) # 6 print(args) # (7, 8, 9) print(kwargs) # {'b': 2, 'c': 3, 'd': 4} function(6, 7, 8, 9, b=2, c=3, d=4) 要点 位置参数、可变参数、可变关键字参数 类型的区别： 位置参数类型为传入参数的类型 可变参数类型为元组 可变关键字参数类型为字典 调用的区别： 可变参数不需要key， 可变关键字参数需要key， 调用时位置参数、可变参数、可变关键字参数位置是固定的， 定义的区别： 定义时位置参数、可变参数、可变关键字参数位置是固定的 "},"chapter3/3.6.html":{"url":"chapter3/3.6.html","title":"3.6 Python装饰器详解","keywords":"","body":"3.6 Python装饰器详解 代码 import time from functools import wraps def runtime(function): @wraps(function) def get_now_time(*args, **kwargs): print(time.asctime()) return function(*args, **kwargs) return get_now_time @runtime def run(*args, **kwargs): print(args) print(kwargs) run('HaHa') run('HaHa', 'HeHe') run('HaHa', 'HeHe', a=1, b=2) "},"chapter3/3.7.html":{"url":"chapter3/3.7.html","title":"3.7 return和yield的区别","keywords":"","body":"3.7 return和yield的区别 题目 def func1(): for i in range(1, 5): return i def func2(): for i in range(1, 5): yield i print(func1()) # 1 print(func2()) # yi = func2() print(type(yi)) # for i in yi: print(i, end=' ') # 1 2 3 4 区别 return阻断了循环，return后循环中断，不再执行 yield返回一个生成器 "},"chapter3/3.8.html":{"url":"chapter3/3.8.html","title":"3.8 多种推导式的实现","keywords":"","body":"3.8 多种推导式的实现 代码 list1 = [1, 2, 3, 4] # 用map和lambda解决 result = map(lambda x: x * x, list1) print(list(result)) # [1, 4, 9, 16] # 使用列表推导式 list2 = [i * i for i in list1] print(list2) # [1, 4, 9, 16] list3 = [i * i for i in list1 if i > 2] print(list3) # [9, 16] # 集合推导式 list1 = {1, 2, 3, 4} list2 = {i * i for i in list1} print(list2) # {16, 1, 4, 9}，注意集合是无序的 # 字典推导式 my_json = { \"key1\": 10, \"key2\": 20, \"key3\": 30 } keys = {value: key for key, value in my_json.items()} print(keys) # {10: 'key1', 20: 'key2', 30: 'key3'} "},"chapter3/3.9.html":{"url":"chapter3/3.9.html","title":"3.9 排序算法的复杂度解释","keywords":"","body":"3.9 排序算法的复杂度解释 常见的排序算法 插入排序 希尔排序 直接排序 堆排序 冒泡排序 快速排序 归并排序 基数排序 常考的排序算法 冒泡排序 快速排序 例如：给定一个列表，将这个列表进行排序，要求：时间复杂度小于O(n^2) 复杂度 时间复杂度：指算法在计算的过程中所需要的计算工作量 空间复杂度：指算法在计算过程中所需要的内存空间 常见的时间复杂度 常数阶：O(1) 对数阶：O(log2n) 线性阶：O(n) 线性对数阶：O(nlog2n) 平方阶：O(n^2) 立方阶：O(n^3) "},"chapter3/3.10.html":{"url":"chapter3/3.10.html","title":"3.10 冒泡的时间复杂度及思想","keywords":"","body":"3.10 冒泡的时间复杂度及思想 冒泡排序的实现 相邻的两个数字进行比较，大的向下沉，最后一个元素是最大的 时间复杂度是O(n^2) 实现 def bubble_sort(blist): count = len(blist) for i in range(0, count): for j in range(i + 1, count): if blist[i] > blist[j]: blist[i], blist[j] = blist[j], blist[i] return blist blist = bubble_sort([32, 12, 45, 64, 1, 5, 8]) print(blist) # [1, 5, 8, 12, 32, 45, 64] "},"chapter3/3.11.html":{"url":"chapter3/3.11.html","title":"3.11 快排的时间复杂度及实现思想","keywords":"","body":"3.11 快排的时间复杂度及实现思想 快速排序的思想 递归 列表中取出第一个元素，作为标准，把比第一个元素小的都放在左侧，把比第一个元素大的都放在右边 递归完成时就是排序结束的时候 时间复杂度：O(nlog2n) 实现 def quick_sort(quick_list): if quick_list == []: return [] else: first = quick_list[0] # 推导式实现 less = quick_sort([l for l in quick_list[1:] if l first]) return less + [first] + more blist = quick_sort([32, 12, 45, 64, 1, 5, 8]) print(blist) # [1, 5, 8, 12, 32, 45, 64] "},"chapter4/readme.html":{"url":"chapter4/readme.html","title":"第4章 一面-面向对象、函数式编程面试考点","keywords":"","body":"第4章 一面-面向对象、函数式编程面试考点 本章内容为：面向对象、函数式编程 "},"chapter4/4.1.html":{"url":"chapter4/4.1.html","title":"4.1 面试真题及考点分析","keywords":"","body":"4.1 面试真题及考点分析 面试题1：概述如何理解面向对象以及面向对象的特点 重点不是后面的特点，而是前面的如何理解面向对象 面试题2：类中的私有变量是否能访问，如果能，那么如何访问 面试题3：Python中的类有多少方法种类，他们有什么区别 面试题4：用函数实现过滤掉集合list1=['','hello',None,'python']中的空格和空值 代码list1 = ['', 'hello', None, 'python'] print(list(filter(lambda x: x, list1))) # ['hello', 'python'] 面试题5：用函数方法实现计算集合list1=[1,2,3,4,5]中，所有元素的和 代码 from functools import reduce list1 = [1, 2, 3, 4, 5] print(reduce(lambda x, y: x + y, list1)) # 15 "},"chapter4/4.2.html":{"url":"chapter4/4.2.html","title":"4.2 Python中的私有变量能访问么","keywords":"","body":"4.2 Python中的私有变量能访问么 可以访问 class Student: __name = '三毛' school = '北大' print(Student.school) # 北大 # print(Student.__name) # 报错，Student 没有属性__name print(dir(Student)) # ['_Student__name'...] print(Student._Student__name) # 三毛 "},"chapter4/4.3.html":{"url":"chapter4/4.3.html","title":"4.3 Python中类的方法种类及区别","keywords":"","body":"4.3 Python中类的方法种类及区别 实例方法 实例可以操作的方法 实例方法可以操作实例变量 和实例相关的方法 类方法 类可以直接调用 类方法可以操作类变量 和类相关的方法 静态方法 脱离了类而存在 不能操作类变量，也不能操作实例变量 主要用于工具方法 示例 class Student: name = '四毛' def eat(self): # 实例方法 print('学生吃') @classmethod def study(cls): # 类方法 print(cls.name + 'Student study') @staticmethod # 静态方法 def run(): print('student run') def __kaoshi(self): print('学生考试') s = Student() s.eat() # 学生吃 Student.study() # 四毛Student study Student.run() # student run s._Student__kaoshi() # 学生考试 Student._Student__kaoshi(Student()) # 学生考试 "},"chapter4/4.4.html":{"url":"chapter4/4.4.html","title":"4.4 面向对象的理解","keywords":"","body":"4.4 面向对象的理解 面向对象首先是一种编程思想 面向对象是编程世界想现实世界的一种延伸 也就是说万物皆可以描述，我们用编程语言也可以描述世界万物 类：它就是面向对象的一种表现形式 "},"chapter4/4.5.html":{"url":"chapter4/4.5.html","title":"4.5 面向对象三大特性演示","keywords":"","body":"4.5 面向对象三大特性演示 封装 继承 多态 示例 class Animal: def run(self): print('animal run') def eat(self): print('animal eat') def talk(self): print('animal talk') a = Animal() a.run() # animal run class Person(Animal): def study(self): print('person study') def talk(self): print('person talk') p = Person() p.eat() # animal eat p.study() # person study class Dog(Animal): def talk(self): print('dog talk') d = Dog() d.talk() # dog talk p.talk() # person talk "},"chapter5/readme.html":{"url":"chapter5/readme.html","title":"第5章 一面-网络知识考试点","keywords":"","body":"第5章 一面-网络知识考试点 本章介绍网络相关知识点 "},"chapter5/5.1.html":{"url":"chapter5/5.1.html","title":"5.1 网络面试真题及考点分析","keywords":"","body":"5.1 网络面试真题及考点分析 面试题1：请说明session和cookie的作用和区别 面试题2：HTTP协议如何保证数据在传输过程中不丢失 协议分层 握手、挥手机制 面试题2：简要说明请求头中Accept\\Accept-Encoding\\Accept-Lanuage都代表了什么意思 "},"chapter5/5.2.html":{"url":"chapter5/5.2.html","title":"5.2 cookies和session的存储和区别","keywords":"","body":"5.2 cookies和session的存储和区别 区别 cookie在客户端的头信息中 session在服务端存储，文件、数据库等都可以 一般来说，session的验证需要cookie带一个字段来表示这个用户是哪一个session，所以当客户端禁用cookie时，session将失效 cookie cookie就是一小段文本信息 cookie的格式为key:value cookie的值由服务端生成，客户端保存 "},"chapter5/5.3.html":{"url":"chapter5/5.3.html","title":"5.3 OSI网络协议分层详解","keywords":"","body":"5.3 OSI网络协议分层详解 OSI分层 应用层：为应用程序提供服务 表示层：数据格式转化及加密操作 会话层：建立、管理和维护会话 传输层：建立、管理和维护端到端的连接 网络层：IP地址及路由选择 数据链路层：提供介质访问和链路管理 物理层：物理层，即物理设备 举例说明 老张向老王提供了一份货物及价格清单 怕别的竞争对手公司看到，给清单做了加密 市场部整理后将报价清单放大收发室 收发室将报价清单送到快递公司 快递公司分发到不同集散中心 运输路线的规划及各集散中心访问方式 通过汽车、火车、飞机等设备进行运输 TCP/IP五层协议 应用层：HTTP/HTTPS/FTP/SMTP 传输层：TCP/UDP 网络层：IP/ICMP 数据链路层：ARP/RARP 物理层:MLT-3/PAM5 "},"chapter5/5.4.html":{"url":"chapter5/5.4.html","title":"5.4 HTTP协议数据不丢失的网络机制","keywords":"","body":"5.4 HTTP协议数据不丢失的网络机制 HTTP三次握手机制 客户端-->服务端 SYN=1,Seq=x 服务端-->客户端 SYN=1,ACK=x+1,Seq=Y 客户端-->服务端 SYN=1,ACK=Y+1,Seq=z HTTP四次挥手机制 客户端-->服务端 FIN=1,Seq=u 服务端-->客户端 ACK=u+1,Seq=v,ACK=1 服务端-->客户端 FIN=1,ack=u+1,seq=w,ACK=1 客户端-->服务端 ACK=W+1,seq=u+1,ACK=1 "},"chapter5/5.5.html":{"url":"chapter5/5.5.html","title":"5.5 HTTP协议信息头详解","keywords":"","body":"5.5 HTTP协议信息头详解 请求头 Accept：浏览器告诉服务器它所支持的数据类型 Accept-Charset：浏览器告诉服务器它采用的字符集 Accept-Encoding：浏览器告诉服务器它所支持的压缩格式 Accept-Language：浏览器告诉服务器它所采用的语言 Host：浏览器告诉服务器我想访问服务器哪台主机 If-Modified-Since：浏览器告诉服务器它缓存数据时间是多少 Referer：浏览器告诉服务器我是从哪个网页点过来的(防盗链) User-Agent：浏览器告诉服务器我所采用的浏览器类型、版本等信息 Date：浏览器告诉服务器我什么时间访问的 响应头 Location：告诉浏览器你去找谁，配合302状态码使用 Server：告诉浏览器服务器的类型 Content-Encoding：告诉浏览器回送的数据采用的压缩格式 Content-Type：告诉浏览器回送的数据类型 Last-Modified：告诉浏览器数据的最后修改时间 Refresh：用于控制浏览器定时刷新 Content-Disposition：告诉浏览器需要以下载方式打开回送的数据 Transfer-Encoding：告诉浏览器数据是以分块形式回送的 "},"chapter6/readme.html":{"url":"chapter6/readme.html","title":"第6章 一面-web自动化面试考点","keywords":"","body":"第6章 一面-web自动化面试考点 本章介绍Web自动化知识点 "},"chapter6/6.1.html":{"url":"chapter6/6.1.html","title":"6.1 web自动化面试真题及技术点讲解","keywords":"","body":"6.1 web自动化面试真题及技术点讲解 面试题1：你的自动化是如何落地的？遇到了什么难点？ 遇到过哪些比较难定位的元素，你是如何定位的？ 验证码的问题你是如何解决的？ 你的自动化框架是如何设计的？ "},"chapter6/6.2.html":{"url":"chapter6/6.2.html","title":"6.2 web自动化落地过程和难点分析","keywords":"","body":"6.2 web自动化落地过程和难点分析 项目过程 立项 文档 代码编写 单元测试 测试准入 功能测试 性能测试 集成测试 测试报告 上线部署 线上回归 什么时候开始自动化才是最好的时间点呢？ 自动化切入点 测试准入 集成测试 线上回归 落地过程中具体难点有哪些 前端代码改动大、频繁或不规范导致元素不好定位 自动化刚开始时，测试人员编码规范及架构设计不统一 "},"chapter6/6.3.html":{"url":"chapter6/6.3.html","title":"6.3 下拉框定位","keywords":"","body":"6.3 下拉框定位 滚动条 from selenium import webdriver option = webdriver.ChromeOptions() option.add_argument('disable-infobars') driver = webdriver.Chrome(chrome_options=option, executable_path=r'C:\\Python37\\chromedriver') driver.get('https://www.jd.com') driver.set_window_size(600, 800) js = 'window.scrollTo(10000, 10000);' driver.execute_script(js) "},"chapter6/6.4.html":{"url":"chapter6/6.4.html","title":"6.4 定位日期控件及js调试方法","keywords":"","body":"6.4 定位日期控件及js调试方法 日期 from selenium import webdriver import time option = webdriver.ChromeOptions() option.add_argument('disable-infobars') driver = webdriver.Chrome(chrome_options=option, executable_path=r'C:\\Python37\\chromedriver') driver.get('https://www.12306.cn/index/') js = \"document.getElementById('train_date').removeAttribute('readonly')\" driver.execute_script(js) driver.find_element_by_id('train_date').clear() time.sleep(2) driver.find_element_by_id('train_date').send_keys('2018-12-12') js调试方法 使用浏览器自带console输入对应的js "},"chapter6/6.5.html":{"url":"chapter6/6.5.html","title":"6.5 页面弹出框的处理","keywords":"","body":"6.5 页面弹出框的处理 百度登录框 from selenium import webdriver import time option = webdriver.ChromeOptions() option.add_argument('disable-infobars') driver = webdriver.Chrome(chrome_options=option, executable_path=r'C:\\Python37\\chromedriver') driver.get('https://www.baidu.com') driver.find_element_by_link_text('登录').click() time.sleep(2) driver.find_element_by_id('TANGRAM__PSP_10__footerULoginBtn').click() driver.find_element_by_id('TANGRAM__PSP_10__userName').send_keys('aaa') 浏览器自带弹出框 "},"chapter6/6.6.html":{"url":"chapter6/6.6.html","title":"6.6 浏览器自带弹出框定位","keywords":"","body":"6.6 浏览器自带弹出框定位 测试文件 function disp_alert() { alert(\"I am alert!\") } function show_confirm() { var r=confirm(\"Press a button!\"); if (r==true) { alert(\"You pressed OK!\"); } else { alert(\"You pressed Cancel!\"); } } function disp_prompt() { var name=prompt(\"input your name\",\"zhou\") if (name!=null && name!=\"\") { document.write(\"Hello!\" + name + \" How are you?\") } } 脚本 from selenium import webdriver import time option = webdriver.ChromeOptions() option.add_argument('disable-infobars') driver = webdriver.Chrome(chrome_options=option, executable_path=r'C:\\Python37\\chromedriver') driver.get(r'file:///D:/PythonProject/PytestProject/message.html') driver.find_element_by_id('alert').click() alert = driver.switch_to.alert time.sleep(2) alert.accept() # 同意 driver.find_element_by_id('confirm').click() alert = driver.switch_to.alert time.sleep(2) alert.dismiss() # 取消 alert.accept() driver.find_element_by_id('prompt').click() alert = driver.switch_to.alert time.sleep(2) alert.send_keys('aaaaa') time.sleep(2) alert.accept() "},"chapter6/6.7.html":{"url":"chapter6/6.7.html","title":"6.7 浏览器句柄切换","keywords":"","body":"6.7 浏览器句柄切换 脚本 from selenium import webdriver import time option = webdriver.ChromeOptions() option.add_argument('disable-infobars') driver = webdriver.Chrome(chrome_options=option, executable_path=r'C:\\Python37\\chromedriver') driver.get('https://www.sohu.com') # # 方法1 # window = driver.find_element_by_link_text('新闻').click() # windows = driver.window_handles # 所有句柄 # # for current_windows in windows: # if current_windows != window: # driver.switch_to.window(current_windows) # time.sleep(2) # driver.quit() # 方法2 driver.find_element_by_link_text('新闻').click() windows = driver.window_handles driver.switch_to.window(windows[-1]) time.sleep(2) driver.quit() "},"chapter6/6.8.html":{"url":"chapter6/6.8.html","title":"6.8 验证码解决思路","keywords":"","body":"6.8 验证码解决思路 识别 Python当中提供了一部分图片验证码识别的库 调用别人免费的API接口：比如：百度AI开放平台、腾讯优图 尽量不用识别 万能验证码 开发同学提供的。 缺点是：开发有工作量，到生产环境这个逻辑需要去掉 Debug 手工输入后，再执行代码点击登陆。 缺点：不能持续集成 到数据库中拿 验证码生成逻辑： 后端有一个算法，生成验证码，保存后，传给前端，前端展示 保存的位置：数据库（Redis：自己维护过期时间） 测试同学就到这个Redis当中读一下这个验证码就可以了。 图片也是数据的一种，它在数据库中就是一个字符串 这里作为测试同学，需要搞清楚一个逻辑：身份验证。 "},"chapter6/6.9.html":{"url":"chapter6/6.9.html","title":"6.9 如何保证元素定位的成功率","keywords":"","body":"6.9 如何保证元素定位的成功率 强制等待 隐式等待 显示等待 示例 import time # 强制等待 # time.sleep(2) # 隐性等待 from selenium import webdriver # driver = webdriver.Chrome(executable_path=\"/workspace/tanxin/chromedriver\") # driver.implicitly_wait(5) # # driver.get(\"https://www.sohu.com\") # print(driver.current_url) # driver.quit() # 隐性等待设置的是最长的等待时间，只有在页面完全加载完成才执行下一步 # 隐性等待对整个driver的周期都起作用，只要设置一次就行了。 # 什么叫做完全加载完成？左上角的圈儿不再转了 # 合理的一种加载方式：检测我的元素，是否被加载到。 # 显性等待 from selenium.webdriver.support.wait import WebDriverWait from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.common.by import By driver = webdriver.Chrome(executable_path=\"/workspace/tanxin/chromedriver\") driver.implicitly_wait(10) # 隐性等待和显性等待是可以同时使用的，等待的最长时间取决于两者之中的最大者 driver.get(\"https://www.baidu.com\") try: WebDriverWait(driver, 15, 0.5).until(EC.presence_of_element_located((By.LINK_TEXT,'登录'))) print(driver.find_element_by_link_text('登录').get_attribute('href')) finally: driver.close() "},"chapter6/6.10.html":{"url":"chapter6/6.10.html","title":"6.10 框架设计PO模式BasePage封装","keywords":"","body":"6.10 框架设计PO模式BasePage封装 参考Github "},"chapter6/6.11.html":{"url":"chapter6/6.11.html","title":"6.11 框架设计PO完整封装","keywords":"","body":"6.11 框架设计PO完整封装 参考Github "},"chapter6/6.12.html":{"url":"chapter6/6.12.html","title":"6.12 PO模式总结","keywords":"","body":"6.12 PO模式总结 PO为什么会出现？ 页面对象模型！当页面特别多的时候，我们的代码更容易维护 PO是什么？ Page Object ，是一种设计模式，用来管理和维护一组web元素的对象库 在PO模式下，应用程序的每一个页面都有一个对应的page class 每一个page class维护着该页面的元素集合和操作这些元素的方法 PO的优势 PO提供了一种业务流程与页面元素分离的模式，这使得测试代码变得更加的清晰 页面对象与用例分离，使得我们能够更好的复用对象 可复用的页面代码会使得我们的代码风格更加的优秀、优化 "},"chapter6/6.13.html":{"url":"chapter6/6.13.html","title":"6.13 UI自动化必问面试题","keywords":"","body":"6.13 UI自动化必问面试题 selenium框架中driver的quit方法和close方法有什么区别？ selenium框架中鼠标悬停用什么方法？ selenium框架中等待有几种方法，都是什么区别？ 在UI自动化中，是否使用过cookie，如果使用过，那么使用场景和方法是什么？ "},"chapter7/readme.html":{"url":"chapter7/readme.html","title":"第7章 一面-接口自动化与持续集成面试考点","keywords":"","body":"第7章 一面-接口自动化与持续集成面试考点 本章为接口自动化知识 "},"chapter7/7.1.html":{"url":"chapter7/7.1.html","title":"7.1 接口自动化落地过程详解","keywords":"","body":"7.1 接口自动化落地过程详解 项目生命周期 立项 文档 代码编写 单元测试 测试准入 web自动化 接口自动化 功能测试 性能测试 集成测试 web自动化 接口自动化 集成功能测试 上线部署 线上回归 web自动化 接口自动化 性能测试 "},"chapter7/7.2.html":{"url":"chapter7/7.2.html","title":"7.2 接口测试和持续集成面试考点","keywords":"","body":"7.2 接口测试和持续集成面试考点 你的接口自动化是如何做的？ 你常用的接口请求方式及区别？ 你的持续集成是怎么做的？ "},"chapter7/7.3.html":{"url":"chapter7/7.3.html","title":"7.3 接口自动化落地难点","keywords":"","body":"7.3 接口自动化落地难点 接口文档的管理（创建与维护） 多测试人员协同开发时的case维护 "},"chapter7/7.4.html":{"url":"chapter7/7.4.html","title":"7.4 接口自动化常见面试题","keywords":"","body":"7.4 接口自动化常见面试题 常用的接口自动化数据传递方式及区别 get和post 区别：两个角度来回答，数据格式和数据传递位置 get：url填写，key1=value1&key2=value2 post：在请求体里面，json格式 接口测试中常用的库 requests库和urlib库 "},"chapter7/7.5.html":{"url":"chapter7/7.5.html","title":"7.5 持续集成落地过程及面试重点","keywords":"","body":"7.5 持续集成落地过程及面试重点 项目生命周期 立项、文档、代码编写、单元测试 测试准入 内部集成：Jenkins环境自动部署、web自动化、接口自动化、性能基准测试 功能测试 性能测试 外部集成,全链路测试：Jenkins环境自动部署，web自动化、接口自动化、性能测试 上线部署 线上回归：上线回归测试，web自动化，接口自动化，性能测试 "},"chapter8/readme.html":{"url":"chapter8/readme.html","title":"第8章 一面-性能测试进阶面试考点-java性能调优","keywords":"","body":"第8章 一面-性能测试进阶面试考点-java性能调优 本章介绍性能测试知识 "},"chapter8/8.1.html":{"url":"chapter8/8.1.html","title":"8.1 jvm性能测试面试题考察点","keywords":"","body":"8.1 jvm性能测试面试题考察点 什么是内存溢出，为什么会内存溢出 JVM的内存区域是如何划分的 JVM是如何进行垃圾回收的 "},"chapter8/8.2.html":{"url":"chapter8/8.2.html","title":"8.2 图解jvm内存区域划分","keywords":"","body":"8.2 图解jvm内存区域划分 略 "},"chapter8/8.3.html":{"url":"chapter8/8.3.html","title":"8.3 理解jvm中垃圾回收的原因","keywords":"","body":"8.3 理解jvm中垃圾回收的原因 略 "},"chapter8/8.4.html":{"url":"chapter8/8.4.html","title":"8.4 jvm垃圾收集算法","keywords":"","body":"8.4 jvm垃圾收集算法 略 "},"chapter8/8.5.html":{"url":"chapter8/8.5.html","title":"8.5 补充操作文档的说明","keywords":"","body":"8.5 补充操作文档的说明 略 "},"chapter9/readme.html":{"url":"chapter9/readme.html","title":"第9章 一面-MySQL数据库使用及数据库性能调优面试考点","keywords":"","body":"第9章 一面-MySQL数据库使用及数据库性能调优面试考点 本章介绍MySQL知识点 "},"chapter9/9.1.html":{"url":"chapter9/9.1.html","title":"9.1 面试真题及技术点分析","keywords":"","body":"9.1 面试真题及技术点分析 MySQL中索引什么作用？ 如何分析一条查询SQL的效率？ MySQL的常用存储引擎有什么？区别是什么？ "},"chapter9/9.2.html":{"url":"chapter9/9.2.html","title":"9.2 索引在不同引擎中的存储形式","keywords":"","body":"9.2 索引在不同引擎中的存储形式 索引的定义和创建的目的 索引是对数据库表中的一列或多列的值进行排序的一种结构 使用索引可以快速访问数据库表中的特定信息 创建索引的目的就是加快检索表中数据的速度，也就是查询数据的速度 索引的分类 索引是越多越好吗 不是，索引过多的创建，会带来数据的写入的代价过高，即减慢数据写入速度 上面回答不够完整 MyISAM引擎的话仅更新存储表索引文件，影响不是很大 InnodDB引擎则影响大 MyISAM引擎 数据的存储分为三个文件 Table.frm：存储表定义 Table.MYD：存储表数据 Table.MYI：存储表索引 InnodDB引擎 存储方式 共享表空间（常用） 一个表中数据可以横跨多个文件：文件1、文件2、文件3、...文件n 单独表空间 文件1：也是表1的数据 文件2：也是表2的数据 文件3：也是表n的数据 "},"chapter9/9.3.html":{"url":"chapter9/9.3.html","title":"9.3 不同引擎下索引是如何工作的","keywords":"","body":"9.3 不同引擎下索引是如何工作的 MyISAM引擎 例如：看书-->查看目录-->找到内容 InnoDB引擎 例如：逛超市-->找到某个区域-->找到具体商品 "},"chapter9/9.4.html":{"url":"chapter9/9.4.html","title":"9.4 MySQL常用引擎的特点和区别","keywords":"","body":"9.4 MySQL常用引擎的特点和区别 MyISAM引擎的特点 在进行数据的备份、迁移、恢复等操作时，非常的容易，只要对文件进行操作就可以 MyISAM只支持表锁，没有行锁 MyISAM不支持事务安全，但每次读的操作时具有原子性的，所以不必担心脏读等情况 InnoDB引擎的特点 支持事务、回滚、奔溃修复，所以对数据安全性比较高的业务场景都选择了这个引擎 支持行级锁，行级锁的支持大大提高了数据库的并发操作能力 支持外键约束，在MySQL中，只有InndoDB支持外键，在范式设计的原则下，外键约束保证了数据的完整性 脏读 三范式 "},"chapter9/9.5.html":{"url":"chapter9/9.5.html","title":"9.5 SQL语句的效率分析","keywords":"","body":"9.5 SQL语句的效率分析 执行计划：explain 语法：explain SQL语句 "},"chapter10/readme.html":{"url":"chapter10/readme.html","title":"第10章 一面-Linux操作系统基本操作及系统性能监控","keywords":"","body":"第10章 一面-Linux操作系统基本操作及系统性能监控 Linux相关知识点 "},"chapter10/10.1.html":{"url":"chapter10/10.1.html","title":"10.1 Linux操作命令面试真题及讲解","keywords":"","body":"10.1 Linux操作命令面试真题及讲解 如何动态查看文件中你关系的内容，比如error信息 tail -f xx | grep error 如何跨服务器拷贝你的文件？ scp 超大文件在跨服务器拷贝中，经常断开，你是怎么解决的？ rsync，类似断点续传 文件查看常用命令有什么？请讲述他们的区别 tail more less cat 如何去除文件中的重复行 cat data | sort | uniq 如何通过监控命令查看服务器的平均负载值 "},"chapter10/10.2.html":{"url":"chapter10/10.2.html","title":"10.2 Linux监控命令说明","keywords":"","body":"10.2 Linux监控命令说明 参考文档 "},"chapter11/readme.html":{"url":"chapter11/readme.html","title":"第11章 二面-项目面试的核心考察点","keywords":"","body":"第11章 二面-项目面试的核心考察点 本章介绍二面的知识 "},"chapter11/11.1.html":{"url":"chapter11/11.1.html","title":"11.1 项目面试真题","keywords":"","body":"11.1 项目面试真题 你是如何保证项目质量的 你是如何推进项目进度的 推进项目的过程中遇到了哪些问题 "},"chapter11/11.2.html":{"url":"chapter11/11.2.html","title":"11.2 你是如何保证项目质量的","keywords":"","body":"11.2 你是如何保证项目质量的 项目生命周期 立项、文档、代码编写、单元测试 尽早了解项目需求 主动要求了解需求 在开发写代码时写测试代码 测试准入 写好测试用例 测试用例通过才能准入 内部集成：Jenkins环境自动部署、web自动化、接口自动化、性能基准测试 执行web自动化、接口自动化 功能测试 性能测试 外部集成：全链路测试，Jenkins环境自动部署、web自动化、接口自动化、性能测试 上线部署 线上回归 上线回归测试 web自动化 接口自动化 性能测试 要点 文档阶段：把控需求，充分理解需求 原型评审：交互方面理解一致 用例评审：多角色监管，避免漏测 准入规则：高质量提测 "},"chapter11/11.3.html":{"url":"chapter11/11.3.html","title":"11.3 你是如何推进项目进度的","keywords":"","body":"11.3 你是如何推进项目进度的 站会：同步开发与测试进度 分模块自动化测试：提高测试效率 持续集成：降低集成测试成本 多沟通：提前评估意外的需求变更带来的风险 和上级沟通 和产品经理沟通 和项目经理沟通 "},"chapter11/11.4.html":{"url":"chapter11/11.4.html","title":"11.4 项目中遇到了哪些问题","keywords":"","body":"11.4 项目中遇到了哪些问题 内部问题 无自动化、测试效率低 推进自动化的测试能力 有自动化，但用例维护不及时 推进用例以原始数据的形式存储在数据库中 外部问题 无文档 与开发人员属于同一团队的情况：经常沟通 与开发人员不属于同一团队的情况：同对方团队的leader沟通，自上而下推动 有文档，但文档更新不及时 提高自己对文档的重视：经常沟通，拿文档沟通，让别人知道你对文档的重视 "},"chapter11/11.5.html":{"url":"chapter11/11.5.html","title":"11.5 为项目做了哪些贡献","keywords":"","body":"11.5 为项目做了哪些贡献 突出价值 工作成果数字化 提高50%的测试效率 提高30%的测试覆盖率 价值高度化 推进项目流程的标准化 文档建设 持续集成 测试准入 "},"chapter12/readme.html":{"url":"chapter12/readme.html","title":"第12章 综合素质面试","keywords":"","body":"第12章 综合素质面试 综合素质面试的知识点 "},"chapter12/12.1.html":{"url":"chapter12/12.1.html","title":"12.1 综合素质面试的核心考察点","keywords":"","body":"12.1 综合素质面试的核心考察点 性格 随和 奉献精神 稳定性 沟通能力 团队协作能力 管理能力 个人管理能力，良好的习惯，工作和生活中的管理能力能力，业余爱好 团队管理能力，协调能力 目标感和责任感 是否愿意为这家公司拼搏 职业规划 真题1：业务能力 特定行业的业务知识 真题2：团队中有人不服你怎么办 管理岗必备 真题3：未来的职业规划 真题4：你认为你能够胜任的这个工作的原因是什么 自己的优点 匹配度 真题5：为什么要离职 真题6：团队中工作需要加班，你会如何处理 "},"chapter12/12.2.html":{"url":"chapter12/12.2.html","title":"12.2 解决人际关系","keywords":"","body":"12.2 解决人际关系 团队中有人不服你怎么办？ 男人：吃饭、喝酒、玩游戏，成为朋友 女人：请她帮忙，如她旅游，请她带东西 关键点：从工作外解决 "},"chapter12/12.3.html":{"url":"chapter12/12.3.html","title":"12.3 职业规划问题核心点","keywords":"","body":"12.3 职业规划问题核心点 无休止的技术之路 不要纯粹学习 尽自己最大的努力为团队、为公司的效能贡献力量 "},"chapter12/12.4.html":{"url":"chapter12/12.4.html","title":"12.4 为什么我能胜任这份工作","keywords":"","body":"12.4 为什么我能胜任这份工作 个人优势 持续的学习能力：丰富的知识体系可为公司做更大的贡献 乐观的态度：遇到困难优先去想解决方法，而不是逃避 对工作的热情：在工作中能够找到自信与成就感 "},"chapter12/12.5.html":{"url":"chapter12/12.5.html","title":"12.5 离职原因不可触碰的雷区","keywords":"","body":"12.5 离职原因不可触碰的雷区 雷区 吐槽加班 吐槽公司和老板 吐槽团队 吐槽制度 "},"chapter12/12.6.html":{"url":"chapter12/12.6.html","title":"12.6 聊聊加班的问题","keywords":"","body":"12.6 聊聊加班的问题 首先表明态度，不介意加班 思考解决办法 提高工作效率 "},"chapter12/12.7.html":{"url":"chapter12/12.7.html","title":"12.7 个人经典问题与总结","keywords":"","body":"12.7 个人经典问题与总结 你自己有什么缺点 只讲技术方面，比如知识的深度还不够，源码阅读的比较少 切记不要讲性格方面的缺点 结婚与生子 核心：短时间内没有计划 业余时间有什么爱好 一定要是积极向上的爱好：比如看书、运动 对新技术的探索 同事聚会，加强默契与了解 三面核心词 乐观 好学 积极 有责任：不甩锅 随和 奉献 "},"chapter13/readme.html":{"url":"chapter13/readme.html","title":"第13章 课程总结","keywords":"","body":"第13章 课程总结 课程总结 "},"chapter13/13.1.html":{"url":"chapter13/13.1.html","title":"13.1 课程总结","keywords":"","body":"13.1 课程总结 深入方向 硬技能 开发语言：Python、Java 数据库：MySQL、MongoDB、Redis 中间件：Nginx、Tomcat 框架：Flask、Django、SpringBoot、SpringCloud 软技能 为人处世 汇报能力 简历的核心点 价值 数字：体现工作成果 除非你很好看，否则不要轻易贴照片 "}}